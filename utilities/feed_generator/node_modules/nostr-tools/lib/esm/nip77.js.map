{
  "version": 3,
  "sources": ["../../nip77.ts"],
  "sourcesContent": ["import { bytesToHex, hexToBytes } from '@noble/hashes/utils.js'\nimport { Filter } from './filter.ts'\nimport { AbstractRelay, Subscription } from './relay.ts'\nimport { sha256 } from '@noble/hashes/sha2.js'\n\n// Negentropy implementation by Doug Hoyte\nconst PROTOCOL_VERSION = 0x61 // Version 1\nconst ID_SIZE = 32\nconst FINGERPRINT_SIZE = 16\n\nconst Mode = {\n  Skip: 0,\n  Fingerprint: 1,\n  IdList: 2,\n}\n\nclass WrappedBuffer {\n  _raw: Uint8Array\n  length: number\n\n  constructor(buffer?: Uint8Array | number) {\n    if (typeof buffer === 'number') {\n      this._raw = new Uint8Array(buffer)\n      this.length = 0\n    } else if (buffer instanceof Uint8Array) {\n      this._raw = new Uint8Array(buffer)\n      this.length = buffer.length\n    } else {\n      this._raw = new Uint8Array(512)\n      this.length = 0\n    }\n  }\n\n  unwrap(): Uint8Array {\n    return this._raw.subarray(0, this.length)\n  }\n\n  get capacity(): number {\n    return this._raw.byteLength\n  }\n\n  extend(buf: Uint8Array | WrappedBuffer): void {\n    if (buf instanceof WrappedBuffer) buf = buf.unwrap()\n    if (typeof buf.length !== 'number') throw Error('bad length')\n    const targetSize = buf.length + this.length\n    if (this.capacity < targetSize) {\n      const oldRaw = this._raw\n      const newCapacity = Math.max(this.capacity * 2, targetSize)\n      this._raw = new Uint8Array(newCapacity)\n      this._raw.set(oldRaw)\n    }\n\n    this._raw.set(buf, this.length)\n    this.length += buf.length\n  }\n\n  shift(): number {\n    const first = this._raw[0]\n    this._raw = this._raw.subarray(1)\n    this.length--\n    return first\n  }\n\n  shiftN(n: number = 1): Uint8Array {\n    const firstSubarray = this._raw.subarray(0, n)\n    this._raw = this._raw.subarray(n)\n    this.length -= n\n    return firstSubarray\n  }\n}\n\nfunction decodeVarInt(buf: WrappedBuffer): number {\n  let res = 0\n\n  while (1) {\n    if (buf.length === 0) throw Error('parse ends prematurely')\n    let byte = buf.shift()\n    res = (res << 7) | (byte & 127)\n    if ((byte & 128) === 0) break\n  }\n\n  return res\n}\n\nfunction encodeVarInt(n: number): WrappedBuffer {\n  if (n === 0) return new WrappedBuffer(new Uint8Array([0]))\n\n  let o: number[] = []\n\n  while (n !== 0) {\n    o.push(n & 127)\n    n >>>= 7\n  }\n\n  o.reverse()\n\n  for (let i = 0; i < o.length - 1; i++) o[i] |= 128\n\n  return new WrappedBuffer(new Uint8Array(o))\n}\n\nfunction getByte(buf: WrappedBuffer): number {\n  return getBytes(buf, 1)[0]\n}\n\nfunction getBytes(buf: WrappedBuffer, n: number): Uint8Array {\n  if (buf.length < n) throw Error('parse ends prematurely')\n  return buf.shiftN(n)\n}\n\nclass Accumulator {\n  buf!: Uint8Array\n\n  constructor() {\n    this.setToZero()\n  }\n\n  setToZero(): void {\n    this.buf = new Uint8Array(ID_SIZE)\n  }\n\n  add(otherBuf: Uint8Array): void {\n    let currCarry = 0,\n      nextCarry = 0\n    let p = new DataView(this.buf.buffer)\n    let po = new DataView(otherBuf.buffer)\n\n    for (let i = 0; i < 8; i++) {\n      let offset = i * 4\n      let orig = p.getUint32(offset, true)\n      let otherV = po.getUint32(offset, true)\n\n      let next = orig\n\n      next += currCarry\n      next += otherV\n      if (next > 0xffffffff) nextCarry = 1\n\n      p.setUint32(offset, next & 0xffffffff, true)\n      currCarry = nextCarry\n      nextCarry = 0\n    }\n  }\n\n  negate(): void {\n    let p = new DataView(this.buf.buffer)\n\n    for (let i = 0; i < 8; i++) {\n      let offset = i * 4\n      p.setUint32(offset, ~p.getUint32(offset, true))\n    }\n\n    let one = new Uint8Array(ID_SIZE)\n    one[0] = 1\n    this.add(one)\n  }\n\n  getFingerprint(n: number): Uint8Array {\n    let input = new WrappedBuffer()\n    input.extend(this.buf)\n    input.extend(encodeVarInt(n))\n\n    let hash = sha256(input.unwrap())\n    return hash.subarray(0, FINGERPRINT_SIZE)\n  }\n}\n\nexport class NegentropyStorageVector {\n  items: { timestamp: number; id: Uint8Array }[]\n  sealed: boolean\n\n  constructor() {\n    this.items = []\n    this.sealed = false\n  }\n\n  insert(timestamp: number, id: string): void {\n    if (this.sealed) throw Error('already sealed')\n    const idb = hexToBytes(id)\n    if (idb.byteLength !== ID_SIZE) throw Error('bad id size for added item')\n    this.items.push({ timestamp, id: idb })\n  }\n\n  seal(): void {\n    if (this.sealed) throw Error('already sealed')\n    this.sealed = true\n\n    this.items.sort(itemCompare)\n\n    for (let i = 1; i < this.items.length; i++) {\n      if (itemCompare(this.items[i - 1], this.items[i]) === 0) throw Error('duplicate item inserted')\n    }\n  }\n\n  unseal(): void {\n    this.sealed = false\n  }\n\n  size(): number {\n    this._checkSealed()\n    return this.items.length\n  }\n\n  getItem(i: number): { timestamp: number; id: Uint8Array } {\n    this._checkSealed()\n    if (i >= this.items.length) throw Error('out of range')\n    return this.items[i]\n  }\n\n  iterate(begin: number, end: number, cb: (item: { timestamp: number; id: Uint8Array }, i: number) => boolean): void {\n    this._checkSealed()\n    this._checkBounds(begin, end)\n\n    for (let i = begin; i < end; ++i) {\n      if (!cb(this.items[i], i)) break\n    }\n  }\n\n  findLowerBound(begin: number, end: number, bound: { timestamp: number; id: Uint8Array }): number {\n    this._checkSealed()\n    this._checkBounds(begin, end)\n\n    return this._binarySearch(this.items, begin, end, a => itemCompare(a, bound) < 0)\n  }\n\n  fingerprint(begin: number, end: number): Uint8Array {\n    let out = new Accumulator()\n    out.setToZero()\n\n    this.iterate(begin, end, item => {\n      out.add(item.id)\n      return true\n    })\n\n    return out.getFingerprint(end - begin)\n  }\n\n  _checkSealed(): void {\n    if (!this.sealed) throw Error('not sealed')\n  }\n\n  _checkBounds(begin: number, end: number): void {\n    if (begin > end || end > this.items.length) throw Error('bad range')\n  }\n\n  _binarySearch(\n    arr: { timestamp: number; id: Uint8Array }[],\n    first: number,\n    last: number,\n    cmp: (a: { timestamp: number; id: Uint8Array }) => boolean,\n  ): number {\n    let count = last - first\n\n    while (count > 0) {\n      let it = first\n      let step = Math.floor(count / 2)\n      it += step\n\n      if (cmp(arr[it])) {\n        first = ++it\n        count -= step + 1\n      } else {\n        count = step\n      }\n    }\n\n    return first\n  }\n}\n\nexport class Negentropy {\n  storage: NegentropyStorageVector\n  frameSizeLimit: number\n  lastTimestampIn: number\n  lastTimestampOut: number\n\n  constructor(storage: NegentropyStorageVector, frameSizeLimit: number = 60_000) {\n    if (frameSizeLimit < 4096) throw Error('frameSizeLimit too small')\n\n    this.storage = storage\n    this.frameSizeLimit = frameSizeLimit\n\n    this.lastTimestampIn = 0\n    this.lastTimestampOut = 0\n  }\n\n  _bound(timestamp: number, id?: Uint8Array): { timestamp: number; id: Uint8Array } {\n    return { timestamp, id: id || new Uint8Array(0) }\n  }\n\n  initiate(): string {\n    let output = new WrappedBuffer()\n    output.extend(new Uint8Array([PROTOCOL_VERSION]))\n    this.splitRange(0, this.storage.size(), this._bound(Number.MAX_VALUE), output)\n    return bytesToHex(output.unwrap())\n  }\n\n  reconcile(queryMsg: string, onhave?: (id: string) => void, onneed?: (id: string) => void): string | null {\n    const query = new WrappedBuffer(hexToBytes(queryMsg))\n\n    this.lastTimestampIn = this.lastTimestampOut = 0 // reset for each message\n\n    let fullOutput = new WrappedBuffer()\n    fullOutput.extend(new Uint8Array([PROTOCOL_VERSION]))\n\n    let protocolVersion = getByte(query)\n    if (protocolVersion < 0x60 || protocolVersion > 0x6f) throw Error('invalid negentropy protocol version byte')\n    if (protocolVersion !== PROTOCOL_VERSION) {\n      throw Error('unsupported negentropy protocol version requested: ' + (protocolVersion - 0x60))\n    }\n\n    let storageSize = this.storage.size()\n    let prevBound = this._bound(0)\n    let prevIndex = 0\n    let skip = false\n\n    while (query.length !== 0) {\n      let o = new WrappedBuffer()\n\n      let doSkip = () => {\n        if (skip) {\n          skip = false\n          o.extend(this.encodeBound(prevBound))\n          o.extend(encodeVarInt(Mode.Skip))\n        }\n      }\n\n      let currBound = this.decodeBound(query)\n      let mode = decodeVarInt(query)\n\n      let lower = prevIndex\n      let upper = this.storage.findLowerBound(prevIndex, storageSize, currBound)\n\n      if (mode === Mode.Skip) {\n        skip = true\n      } else if (mode === Mode.Fingerprint) {\n        let theirFingerprint = getBytes(query, FINGERPRINT_SIZE)\n        let ourFingerprint = this.storage.fingerprint(lower, upper)\n\n        if (compareUint8Array(theirFingerprint, ourFingerprint) !== 0) {\n          doSkip()\n          this.splitRange(lower, upper, currBound, o)\n        } else {\n          skip = true\n        }\n      } else if (mode === Mode.IdList) {\n        let numIds = decodeVarInt(query)\n\n        let theirElems: { [key: string]: Uint8Array } = {} // stringified Uint8Array -> original Uint8Array (or hex)\n        for (let i = 0; i < numIds; i++) {\n          let e = getBytes(query, ID_SIZE)\n          theirElems[bytesToHex(e)] = e\n        }\n\n        skip = true\n        this.storage.iterate(lower, upper, item => {\n          let k = item.id\n          const id = bytesToHex(k)\n\n          if (!theirElems[id]) {\n            // ID exists on our side, but not their side\n            onhave?.(id)\n          } else {\n            // ID exists on both sides\n            delete theirElems[bytesToHex(k)]\n          }\n\n          return true\n        })\n\n        if (onneed) {\n          for (let v of Object.values(theirElems)) {\n            // ID exists on their side, but not our side\n            onneed(bytesToHex(v))\n          }\n        }\n      } else {\n        throw Error('unexpected mode')\n      }\n\n      if (this.exceededFrameSizeLimit(fullOutput.length + o.length)) {\n        // frameSizeLimit exceeded: stop range processing and return a fingerprint for the remaining range\n        let remainingFingerprint = this.storage.fingerprint(upper, storageSize)\n\n        fullOutput.extend(this.encodeBound(this._bound(Number.MAX_VALUE)))\n        fullOutput.extend(encodeVarInt(Mode.Fingerprint))\n        fullOutput.extend(remainingFingerprint)\n        break\n      } else {\n        fullOutput.extend(o)\n      }\n\n      prevIndex = upper\n      prevBound = currBound\n    }\n\n    return fullOutput.length === 1 ? null : bytesToHex(fullOutput.unwrap())\n  }\n\n  splitRange(lower: number, upper: number, upperBound: { timestamp: number; id: Uint8Array }, o: WrappedBuffer) {\n    let numElems = upper - lower\n    let buckets = 16\n\n    if (numElems < buckets * 2) {\n      o.extend(this.encodeBound(upperBound))\n      o.extend(encodeVarInt(Mode.IdList))\n\n      o.extend(encodeVarInt(numElems))\n      this.storage.iterate(lower, upper, item => {\n        o.extend(item.id)\n        return true\n      })\n    } else {\n      let itemsPerBucket = Math.floor(numElems / buckets)\n      let bucketsWithExtra = numElems % buckets\n      let curr = lower\n\n      for (let i = 0; i < buckets; i++) {\n        let bucketSize = itemsPerBucket + (i < bucketsWithExtra ? 1 : 0)\n        let ourFingerprint = this.storage.fingerprint(curr, curr + bucketSize)\n        curr += bucketSize\n\n        let nextBound: { timestamp: number; id: Uint8Array }\n\n        if (curr === upper) {\n          nextBound = upperBound\n        } else {\n          let prevItem: { timestamp: number; id: Uint8Array } | undefined\n          let currItem: { timestamp: number; id: Uint8Array } | undefined\n\n          this.storage.iterate(curr - 1, curr + 1, (item, index) => {\n            if (index === curr - 1) prevItem = item\n            else currItem = item\n            return true\n          })\n\n          nextBound = this.getMinimalBound(prevItem!, currItem!)\n        }\n\n        o.extend(this.encodeBound(nextBound))\n        o.extend(encodeVarInt(Mode.Fingerprint))\n        o.extend(ourFingerprint)\n      }\n    }\n  }\n\n  exceededFrameSizeLimit(n: number): boolean {\n    return n > this.frameSizeLimit - 200\n  }\n\n  // Decoding\n  decodeTimestampIn(encoded: WrappedBuffer): number {\n    let timestamp = decodeVarInt(encoded)\n    timestamp = timestamp === 0 ? Number.MAX_VALUE : timestamp - 1\n    if (this.lastTimestampIn === Number.MAX_VALUE || timestamp === Number.MAX_VALUE) {\n      this.lastTimestampIn = Number.MAX_VALUE\n      return Number.MAX_VALUE\n    }\n    timestamp += this.lastTimestampIn\n    this.lastTimestampIn = timestamp\n    return timestamp\n  }\n\n  decodeBound(encoded: WrappedBuffer): { timestamp: number; id: Uint8Array } {\n    let timestamp = this.decodeTimestampIn(encoded)\n    let len = decodeVarInt(encoded)\n    if (len > ID_SIZE) throw Error('bound key too long')\n    let id = getBytes(encoded, len)\n    return { timestamp, id }\n  }\n\n  // Encoding\n  encodeTimestampOut(timestamp: number): WrappedBuffer {\n    if (timestamp === Number.MAX_VALUE) {\n      this.lastTimestampOut = Number.MAX_VALUE\n      return encodeVarInt(0)\n    }\n\n    let temp = timestamp\n    timestamp -= this.lastTimestampOut\n    this.lastTimestampOut = temp\n    return encodeVarInt(timestamp + 1)\n  }\n\n  encodeBound(key: { timestamp: number; id: Uint8Array }): WrappedBuffer {\n    let output = new WrappedBuffer()\n\n    output.extend(this.encodeTimestampOut(key.timestamp))\n    output.extend(encodeVarInt(key.id.length))\n    output.extend(key.id)\n\n    return output\n  }\n\n  getMinimalBound(\n    prev: { timestamp: number; id: Uint8Array },\n    curr: { timestamp: number; id: Uint8Array },\n  ): { timestamp: number; id: Uint8Array } {\n    if (curr.timestamp !== prev.timestamp) {\n      return this._bound(curr.timestamp)\n    } else {\n      let sharedPrefixBytes = 0\n      let currKey = curr.id\n      let prevKey = prev.id\n\n      for (let i = 0; i < ID_SIZE; i++) {\n        if (currKey[i] !== prevKey[i]) break\n        sharedPrefixBytes++\n      }\n\n      return this._bound(curr.timestamp, curr.id.subarray(0, sharedPrefixBytes + 1))\n    }\n  }\n}\n\nfunction compareUint8Array(a: Uint8Array, b: Uint8Array): number {\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] < b[i]) return -1\n    if (a[i] > b[i]) return 1\n  }\n\n  if (a.byteLength > b.byteLength) return 1\n  if (a.byteLength < b.byteLength) return -1\n\n  return 0\n}\n\nfunction itemCompare(a: { timestamp: number; id: Uint8Array }, b: { timestamp: number; id: Uint8Array }): number {\n  if (a.timestamp === b.timestamp) {\n    return compareUint8Array(a.id, b.id)\n  }\n\n  return a.timestamp - b.timestamp\n}\n\nexport class NegentropySync {\n  relay: AbstractRelay\n  storage: NegentropyStorageVector\n  private neg: Negentropy\n  private filter: Filter\n  private subscription: Subscription\n  private onhave?: (id: string) => void\n  private onneed?: (id: string) => void\n\n  constructor(\n    relay: AbstractRelay,\n    storage: NegentropyStorageVector,\n    filter: Filter,\n    params: {\n      label?: string\n      onhave?: (id: string) => void\n      onneed?: (id: string) => void\n      onclose?: (errReason?: string) => void\n    } = {},\n  ) {\n    this.relay = relay\n    this.storage = storage\n    this.neg = new Negentropy(storage)\n    this.onhave = params.onhave\n    this.onneed = params.onneed\n    this.filter = filter\n\n    // we prepare a subscription with an empty filter, but it will not be used\n    this.subscription = this.relay.prepareSubscription([{}], { label: params.label || 'negentropy' })\n    this.subscription.oncustom = (data: string[]) => {\n      switch (data[0]) {\n        case 'NEG-MSG': {\n          if (data.length < 3) {\n            console.warn(`got invalid NEG-MSG from ${this.relay.url}: ${data}`)\n          }\n          try {\n            const response = this.neg.reconcile(data[2], this.onhave, this.onneed)\n            if (response) {\n              this.relay.send(`[\"NEG-MSG\", \"${this.subscription.id}\", \"${response}\"]`)\n            } else {\n              this.close()\n              params.onclose?.()\n            }\n          } catch (error) {\n            console.error('negentropy reconcile error:', error)\n            params?.onclose?.(`reconcile error: ${error}`)\n          }\n          break\n        }\n        case 'NEG-CLOSE': {\n          const reason = data[2]\n          console.warn('negentropy error:', reason)\n          params.onclose?.(reason)\n          break\n        }\n        case 'NEG-ERR': {\n          params.onclose?.()\n        }\n      }\n    }\n  }\n\n  async start(): Promise<void> {\n    const initMsg = this.neg.initiate()\n    this.relay.send(`[\"NEG-OPEN\",\"${this.subscription.id}\",${JSON.stringify(this.filter)},\"${initMsg}\"]`)\n  }\n\n  close(): void {\n    this.relay.send(`[\"NEG-CLOSE\",\"${this.subscription.id}\"]`)\n    this.subscription.close()\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
